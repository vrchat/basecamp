// Generated by CoffeeScript 2.3.1
(function() {
  /*
  	basecamp: a wrapper for the basecamp json api
  	todo:
  		check for expired accesses
  */
  var Account, Calendar, Client, Person, Project, _, fs, getAuthUserInfo, opPaths, request, url;

  fs = require('fs');

  url = require('url');

  _ = require('underscore');

  request = require('request');

  opPaths = null;

  getAuthUserInfo = function(access_token, cb) {
    return request({
      url: 'https://launchpad.37signals.com/authorization.json',
      headers: {
        Authorization: 'Bearer ' + access_token
      }
    }, function(error, response, bodyIn) {
      var e, msg, userInfo;
      //		console.log '\nbasecamp: getAuthUserInfo resp', {error, bodyIn}
      if (error) {
        msg = '\nbasecamp: error in getAuthUserInfo\n';
        console.log(msg, {access_token, error, bodyIn});
        cb(msg);
        return;
      }
      try {
        userInfo = JSON.parse(bodyIn);
      } catch (error1) {
        e = error1;
        msg = '\nbasecamp: getAuthUserInfo err in JSON.parse\n';
        console.log(msg, {access_token, bodyIn});
        cb(msg);
        return;
      }
      return cb(null, userInfo);
    });
  };

  exports.Client = Client = class Client {
    constructor(client_id, client_secret, redirect_uri, userAgent) {
      this.client_id = client_id;
      this.client_secret = client_secret;
      this.redirect_uri = redirect_uri;
      this.userAgent = userAgent;
    }

    getAuthNewUrl(state) {
      return "https://launchpad.37signals.com/authorization/new" + "?type=" + 'web_server' + "&client_id=" + this.client_id + "&redirect_uri=" + encodeURIComponent(this.redirect_uri) + (state ? "&state=" + encodeURIComponent(JSON.stringify(state)) : '');
    }

    authNewCallback(req, res, cb) {
      var e, query, ref, ref1, state, stateStr;
      query = url.parse(req.url, true).query;
      stateStr = decodeURIComponent((ref = query.state) != null ? ref : '{}');
      try {
        state = JSON.parse(decodeURIComponent(stateStr));
      } catch (error1) {
        e = error1;
        console.log('basecamp: err in authorization/new callback query.state: ' + stateStr);
        res.end();
        if (typeof cb === "function") {
          cb('query.state err');
        }
        return;
      }
      if (query.error === 'access_denied') {
        res.end(`<html><head>\n	<meta http-equiv="REFRESH" content="0;url=${(ref1 = state.href) != null ? ref1 : '/'}">\n</head><body></body></html> `);
        return;
      }
      if (!query.code || query.error) {
        console.log('basecamp: err in authorization/new callback: ' + req.url);
        res.end();
        if (typeof cb === "function") {
          cb('query.error');
        }
        return;
      }
      return this._getToken(query, null, function(err, userInfo, html) {
        res.end(html);
        return typeof cb === "function" ? cb(err, userInfo) : void 0;
      });
    }

    _getToken(cbQuery, refresh_token, cb) {
      var form, href, html, ref, ref1, state, tokenUrl;
      tokenUrl = "https://launchpad.37signals.com/authorization/token" + "?client_id=" + this.client_id + "&redirect_uri=" + encodeURIComponent(this.redirect_uri) + "&client_secret=" + this.client_secret;
      form = {client_id: this.client_id, redirect_uri: this.redirect_uri, client_secret: this.client_secret};
      if (cbQuery) {
        tokenUrl += '&type=web_server&code=' + cbQuery.code;
        _.extend(form, {
          code: cbQuery.code
        });
        state = JSON.parse((ref = cbQuery.state) != null ? ref : '{}');
        href = (ref1 = state.href) != null ? ref1 : '/';
        html = `<html><head>\n	<meta http-equiv="REFRESH" content="0;url=${href}">\n</head><body></body></html> `;
      } else {
        tokenUrl += '&type=refresh&refresh_token=' + refresh_token;
        _.extend(form, {refresh_token});
      }
      //		console.log '\nbasecamp: POST request params', {tokenUrl, form}
      return request({
        method: 'POST',
        uri: tokenUrl,
        form: form
      }, function(error, response, bodyIn) { // error authorization_expired
        var e, tokenResp;
        
        //			console.log '\nbasecamp: token request resp', {error, bodyIn}
        if (error || bodyIn.indexOf('"error":') !== -1) {
          console.log('\nbasecamp: token request error ', {error, bodyIn, cbQuery, refresh_token});
          if (typeof cb === "function") {
            cb('token request error');
          }
          return;
        }
        try {
          tokenResp = JSON.parse(bodyIn);
        } catch (error1) {
          e = error1;
          console.log('\nbasecamp: token request resp parse error\n', {e, bodyIn, cbQuery, refresh_token});
          if (typeof cb === "function") {
            cb('token request resp parse error');
          }
          return;
        }
        return getAuthUserInfo(tokenResp.access_token, function(err, userInfoIn) {
          var userInfo;
          //				console.log '\nbasecamp: getAuthUserInfo resp', {err, userInfoIn}
          if (err) {
            if (typeof cb === "function") {
              cb('getAuthUserInfo tokenResp err');
            }
            return;
          }
          userInfo = _.extend(tokenResp, userInfoIn, (state ? {state} : void 0));
          return typeof cb === "function" ? cb(null, userInfo, html) : void 0;
        });
      });
    }

    getUserInfo(refresh_token, cb) {
      //		console.log 'basecamp: getUserInfo refresh_token ' + refresh_token
      return this._getToken(null, refresh_token, function(err, userInfo) {
        if (err || !(userInfo != null ? userInfo.refresh_token : void 0)) {
          log('bcr: getUserInfo err or missing refresh_token', {err, userInfo});
          cb('err in getUserInfo');
          return;
        }
        return cb(null, userInfo);
      });
    }

  };

  exports.Account = Account = class Account {
    constructor(client, accountId, access_token1, cb) {
      this.client = client;
      this.accountId = accountId;
      this.access_token = access_token1;
      this.account = null;
      //		console.log '\nbasecamp: new acct constructor', {@accountId, @access_token}
      getAuthUserInfo(this.access_token, (err, userInfo1) => {
        var account, i, len, ref, ref1;
        this.userInfo = userInfo1;
        if (err) {
          cb('new acct getAuthUserInfo err');
          return;
        }
        //			console.log '\nbasecamp: new acct getAuthUserInfo', @userInfo
        if (this.err || !this.userInfo.accounts) {
          console.log('\nbasecamp: new acct getAuthUserInfo error or no accounts', this.accountId, this.err, this.userInfo);
          if (typeof cb === "function") {
            cb('new acct getAuthUserInfo error');
          }
          return;
        }
        ref = this.userInfo.accounts;
        for (i = 0, len = ref.length; i < len; i++) {
          account = ref[i];
          if (account.id === this.accountId) {
            this.account = account;
            break;
          }
        }
        if (!this.account) {
          console.log('\nbasecamp: account not found, ' + this.userInfo.identity.email_address + ', ' + this.accountId);
          cb('basecamp: account not found');
          return;
        }
        if (((ref1 = this.account) != null ? ref1.product : void 0) !== 'bcx') {
          this.err = 'basecamp: error, product ' + (account != null ? account.product : void 0) + ' not supported, ' + this.userInfo.identity.email_address + ', ' + this.accountId;
          console.log('\nbasecamp ' + this.err);
          cb(this.err);
          return;
        }
        return cb(null, this);
      });
    }

    req(op, options, cb) {
      var abortStream, all, body, file, haveQM, headers, i, id, k, len, path, qStr, query, ref, replacement, reqCB, requestOpts, section, stream, streamIt, urlReplacements, v;
      if (!this.account) {
        cb('basecamp: req error, no account');
        return;
      }
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }
      if (!(path = opPaths[op])) {
        cb('basecamp: req error, invalid opcode ' + op);
        return;
      }
      ({section, id, query, headers, body, stream, file, url, all} = options);
      //		console.log 'basecamp: req method ',  {op, accountInstance: @}
      requestOpts = {
        headers: {
          'User-Agent': this.client.userAgent,
          Authorization: 'Bearer ' + this.access_token
        }
      };
      if ((ref = path[0]) === 'P' || ref === 'D') {
        if (!body && !stream && !file) {
          cb('basecamp: req body/stream/file missing', op, options);
          return;
        }
        if (body) {
          requestOpts.json = body;
        }
        requestOpts.method = path.split('/')[0];
        path = path.slice(requestOpts.method.length);
      }
      urlReplacements = [['~primaryId~', this.primaryId], ['~optionalId~', this.primaryId], ['~section~', section], ['~secondaryId~', id]];
      for (i = 0, len = urlReplacements.length; i < len; i++) {
        replacement = urlReplacements[i];
        if (path.indexOf(replacement[0]) !== -1) {
          if (!replacement[1]) {
            if (replacement[0] !== '~optionalId~') {
              cb('option ' + replacement[0].slice(1, -1) + ' missing for ' + path);
              return;
            }
            path = path.replace('/' + replacement[0], '');
          } else {
            path = path.replace(replacement[0], replacement[1]);
          }
        }
      }
      qStr = '';
      if (query) {
        haveQM = path.indexOf('?') !== -1;
        for (k in query) {
          v = query[k];
          qStr += (haveQM ? '&' : '?') + k + '=' + v;
          haveQM = true;
        }
      }
      if (url) {
        requestOpts.url = url;
      } else {
        requestOpts.url = this.account.href + path + qStr; // encodeURIComponent ?
      }
      if (headers) {
        _.extend(requestOpts.headers, headers);
      }
      reqCB = (error, response, bodyIn) => {
        var e, link, nextUrl;
        //			console.log 'basecamp: req callback, err:', error, '/ bodyIn-type:', (typeof bodyIn), '/ status:', response?.statusCode
        if (!error) {
          if (typeof bodyIn === 'string') {
            try {
              body = JSON.parse(bodyIn);
            } catch (error1) {
              e = error1;
              error = bodyIn;
            }
          } else {
            body = bodyIn;
          }
        }
        if (error) {
          console.log('\nbasecamp: req error, bad response ' + op + ' ' + this.account.name, '\n\n', requestOpts, '\n\n', error);
          cb(error);
          return;
        }
        //			console.log '\nbasecamp: response ' + op + ' ' +
        //                        @userInfo.identity.email_address + ' ' + @account.name, body
        if (all) {
          link = response.headers.link;
          nextUrl = "";
          if (link) {
            nextUrl = link.substring(link.lastIndexOf("<") + 1, link.lastIndexOf(">"));
          }
          if (nextUrl) {
            _this.req(op, {
              url: nextUrl
            }, (error, result) => {
              return cb(null, body.concat(result));
            });
          } else {
            return cb(null, body);
          }
        } else {
          return cb(null, body);
        }
      };
      //		console.log '\nbasecamp: pre-request ', {op, stream: stream?, file, requestOpts}
      if (stream || file) {
        abortStream = false;
        streamIt = function() {
          var reqst;
          reqst = stream.pipe(request(requestOpts));
          reqst.on('response', function(resp) {
            if (resp.statusCode >= 400) {
              reqCB('bad stream status code ' + resp.statusCode + ', ' + requestOpts.url);
              return abortStream = true;
            }
          });
          reqst.on('data', function(resp) {
            if (!abortStream) {
              return reqCB(null, null, resp.toString());
            }
          });
          return reqst.on('error', function(resp) {
            if (!abortStream) {
              reqCB('stream error ' + requestOpts.url + ', ' + JSON.stringify(resp));
              return abortStream = true;
            }
          });
        };
        if (stream) {
          streamIt();
          return;
        }
        if (!requestOpts.headers['Content-Length'] && !requestOpts.headers['content-length']) {
          fs.stat(file, function(err, stats) {
            if (err) {
              reqCB('fs.stat error ' + requestOpts.url + JSON.stringify(err));
              return;
            }
            _.extend(requestOpts.headers, {
              'Content-Length': stats.size
            });
            stream = fs.createReadStream(file);
            return streamIt();
          });
          return;
        }
        stream = fs.createReadStream(file);
        return streamIt();
      } else {
        return request(requestOpts, reqCB);
      }
    }

  };

  exports.Project = Project = class Project {
    constructor(account1, projectId) {
      this.account = account1;
      this.projectId = projectId;
      this.account.primaryId = 'projects/' + this.projectId;
    }

    req(...args) {
      return this.account.req(...args);
    }

  };

  exports.Calendar = Calendar = class Calendar {
    constructor(account1, calendarId) {
      this.account = account1;
      this.calendarId = calendarId;
      this.account.primaryId = 'calendars/' + this.calendarId;
    }

    req(...args) {
      return this.account.req(...args);
    }

  };

  exports.Person = Person = class Person {
    constructor(account1, personId) {
      this.account = account1;
      this.personId = personId;
      this.account.primaryId = 'people/' + this.personId;
    }

    req(...args) {
      return this.account.req(...args);
    }

  };

  opPaths = {
    // https://github.com/37signals/bcx-api/blob/master/sections/accesses.md
    get_accesses: '/~primaryId~/accesses.json',
    grant_access: 'POST/~primaryId~/accesses.json',
    revoke_access: 'DELETE/~primaryId~/accesses/~secondaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/attachments.md
    create_attachment: 'POST/attachments.json',
    get_attachments: '/~optionalId~/attachments.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/calendar_events.md
    get_calendar_events: '/~primaryId~/calendar_events.json',
    get_calendar_events_past: '/~primaryId~/calendar_events/past.json',
    get_calendar_event: '/~primaryId~/calendar_events/~secondaryId~.json',
    create_calendar_event: 'POST/~primaryId~/calendar_events.json',
    update_calendar_event: 'PUT/~primaryId~/calendar_events/~secondaryId~.json',
    delete_calendar_event: 'DELETE/~primaryId~/calendar_events/~secondaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/calendars.md
    get_calendars: '/calendars.json',
    get_calendar: '/~primaryId~.json',
    create_calendar: 'POST/calendars.json',
    update_calendar: 'PUT/~primaryId~.json',
    delete_calendar: 'DELETE/~primaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/comments.md
    create_comment: 'POST/~primaryId~/~section~/~secondaryId~/comments.json',
    delete_comment: 'DELETE/~primaryId~/comments/~secondaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/documents.md
    get_documents: '/~optionalId~/documents.json',
    get_document: '/~primaryId~/documents/~secondaryId~.json',
    create_document: 'POST/~primaryId~/documents.json',
    update_document: 'PUT/~primaryId~/documents/~secondaryId~.json',
    delete_document: 'DELETE/~primaryId~/documents/~secondaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/events.md
    get_global_events: '/events.json',
    get_project_events: '/~primaryId~/events.json',
    get_person_events: '/~primaryId~/events.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/messages.md
    get_message: '/~primaryId~/messages/~secondaryId~.json',
    create_message: 'POST/~primaryId~/messages.json',
    update_message: 'PUT/~primaryId~/messages/~secondaryId~.json',
    delete_message: 'DELETE/~primaryId~/messages/~secondaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/people.md
    get_people: '/people.json',
    get_person: '/~primaryId~.json',
    get_person_me: '/people/me.json',
    delete_person: 'DELETE/~primaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/projects.md
    get_projects: '/projects.json',
    get_projects_archived: '/projects/archived.json',
    get_project: '/~primaryId~.json',
    create_project: 'POST/projects.json',
    update_project: 'PUT/~primaryId~.json',
    delete_project: 'DELETE/~primaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/todolists.md
    get_todolists: '/~primaryId~/todolists.json',
    get_todolists_completed: '/~primaryId~/todolists/completed.json',
    get_todolists_all: '/todolists.json',
    get_todolists_all_completed: '/todolists/completed.json',
    get_todolists_with_assigned_todos: '/~primaryId~/assigned_todos.json',
    get_todolist: '/~primaryId~/todolists/~secondaryId~.json',
    create_todolist: 'POST/~primaryId~/todolists.json',
    update_todolist: 'PUT/~primaryId~/todolists/~secondaryId~.json',
    delete_todolist: 'DELETE/~primaryId~/todolists/~secondaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/todos.md
    get_todo: '/~primaryId~/todos/~secondaryId~.json',
    create_todo: 'POST/~primaryId~/todos.json',
    update_todo: 'PUT/~primaryId~/todos/~secondaryId~.json',
    delete_todo: 'DELETE/~primaryId~/todos/~secondaryId~.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/topics.md
    get_topics: '/~primaryId~/topics.json',
    get_topics_all: '/topics.json',
    // https://github.com/37signals/bcx-api/blob/master/sections/uploads.md
    create_uploads: 'POST/~primaryId~/uploads.json',
    get_upload: '~primaryId~/uploads/~secondaryId~.json'
  };

}).call(this);
